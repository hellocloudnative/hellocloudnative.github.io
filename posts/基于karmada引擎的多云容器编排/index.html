<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>基于karmada引擎的多云容器编排 | 云原生研习社</title>

<meta name="generator" content="Hugo Eureka 0.9.3" />
<link rel="stylesheet" href="https://hellocloudnative.github.io/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="https://hellocloudnative.github.io/js/eureka.min.e30461307d4134a93cbbd7301a29631abc285b8d3df327389368cd910c20926df5759064caf0f8ba686f65edcbdff5ee.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="https://hellocloudnative.github.io/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="https://hellocloudnative.github.io/js/fontawesome.min.72bacc630098e984944e8c1053095919d626c81a79c840c45732ec238b7067f9fd428502bb949d66209758b95f51eb28.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="https://hellocloudnative.github.io/images/icon_hu567c00f0881afc0330ccceee033e1285_28734_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://hellocloudnative.github.io/images/icon_hu567c00f0881afc0330ccceee033e1285_28734_180x180_fill_box_center_3.png">

<meta name="description"
  content="4 月 25 日，在华为开发者大会 2021（Cloud）上，华为云 CTO 张宇昕宣布云原生多云容器编排项目 Karmada 正式开源。Karmada项目融入华为及工商银行、小红书、中国一汽等各企业在多云管理领域的丰富积累，为开发者提供详实有效的实践指导与帮助，未来还计划将该项目捐赠给云原生计算基金会 CNCF。">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章",
      "item":"https://hellocloudnative.github.io/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"基于karmada引擎的多云容器编排",
      "item":"https://hellocloudnative.github.io/posts/%E5%9F%BA%E4%BA%8Ekarmada%E5%BC%95%E6%93%8E%E7%9A%84%E5%A4%9A%E4%BA%91%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://hellocloudnative.github.io/posts/%E5%9F%BA%E4%BA%8Ekarmada%E5%BC%95%E6%93%8E%E7%9A%84%E5%A4%9A%E4%BA%91%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/"
    },
    "headline": "基于karmada引擎的多云容器编排 | 云原生研习社","datePublished": "2021-05-25T00:00:00+00:00",
    "dateModified": "2021-05-25T00:00:00+00:00",
    "wordCount":  1176 ,
    "author": {
        "@type": "Person",
        "name": ["Pengxuan Zhang"]
    },
    "publisher": {
        "@type": "Person",
        "name": "Pengxuan Zhang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://hellocloudnative.github.io/images/icon.png"
        }
        },
    "description": "\u003cp\u003e4 月 25 日，在华为开发者大会 2021（Cloud）上，华为云 CTO 张宇昕宣布云原生多云容器编排项目 Karmada 正式开源。Karmada项目融入华为及工商银行、小红书、中国一汽等各企业在多云管理领域的丰富积累，为开发者提供详实有效的实践指导与帮助，未来还计划将该项目捐赠给云原生计算基金会 CNCF。\u003c\/p\u003e"
}
</script><meta property="og:title" content="基于karmada引擎的多云容器编排 | 云原生研习社" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://hellocloudnative.github.io/images/icon.png">


<meta property="og:url" content="https://hellocloudnative.github.io/posts/%E5%9F%BA%E4%BA%8Ekarmada%E5%BC%95%E6%93%8E%E7%9A%84%E5%A4%9A%E4%BA%91%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" />




<meta property="og:description" content="4 月 25 日，在华为开发者大会 2021（Cloud）上，华为云 CTO 张宇昕宣布云原生多云容器编排项目 Karmada 正式开源。Karmada项目融入华为及工商银行、小红书、中国一汽等各企业在多云管理领域的丰富积累，为开发者提供详实有效的实践指导与帮助，未来还计划将该项目捐赠给云原生计算基金会 CNCF。" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="云原生研习社" />






<meta property="article:published_time" content="2021-05-25T00:00:00&#43;00:00" />


<meta property="article:modified_time" content="2021-05-25T00:00:00&#43;00:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="karmada" />














  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">云原生研习社</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/authors/pengxuan-zhang/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于我</a>
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
            <a href="/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">分类</a>
            <a href="/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">系列</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">标签</a>
            <a href="/docs/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">文档</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">基于karmada引擎的多云容器编排</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2021-05-25</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>6分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="https://hellocloudnative.github.io/categories/%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%AE%9E%E6%88%98/" class="hover:text-eureka"
          >容器操作实战</a
        >
      
    </div>
  

  
    <div class="me-6 my-2">
      <i class="fas fa-th-list me-1"></i>
      
        <a href="https://hellocloudnative.github.io/series/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%B3%BB%E5%88%97/" class="hover:text-eureka"
          >云原生系列</a
        >
      
    </div>
  
</div>


  
  

  <p>4 月 25 日，在华为开发者大会 2021（Cloud）上，华为云 CTO 张宇昕宣布云原生多云容器编排项目 Karmada 正式开源。Karmada项目融入华为及工商银行、小红书、中国一汽等各企业在多云管理领域的丰富积累，为开发者提供详实有效的实践指导与帮助，未来还计划将该项目捐赠给云原生计算基金会 CNCF。</p>
<h2 id="相关术语">相关术语</h2>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kind</td>
<td>Kubernetes In Docker</td>
<td>使用 Docker 容器作为 Node 并将 Kubernetes 部署至其中的一个工具</td>
</tr>
<tr>
<td>karmada</td>
<td>Kubernetes Armada</td>
<td>是一个Kubernetes管理系统，可让您跨多个Kubernetes群集和云运行您的云原生应用程序，而无需更改应用程序。通过使用Kubernetes原生API并提供高级调度功能，Karmada可以实现真正的开放式多云Kubernetes</td>
</tr>
</tbody>
</table>
<h2 id="一-问题">一． 问题</h2>
<ul>
<li>
<p><strong>单一的集群无法适应现企业业务</strong></p>
<p>虽然现在Kubernetes已经发展到v1.20，但是关于单集群承载能力一直没有变化。可见提高单集群负载能力并不是社区的发展方向。如果我们的业务规模超过了5000台，那么企业不得不考虑多个集群</p>
</li>
<li>
<p><strong>企业趋向于混合云或多云架构逐渐增多</strong></p>
<p>比如企业是一个全球化的公司，提供Global服务。或像新浪微博一样，自建数据中心 + 阿里云，阿里云用于服务弹性流量。另外公有云并没有想象中的海量资源。比如公有云的头部客户特殊情况需要大量机器的时候，需要提前和公有云申请。为了避免被单家供应商锁定，或是出于成本等考虑，企业选择了多云架构，也决定了公司需要多个集群。</p>
</li>
<li>
<p><strong>不把鸡蛋放到一个篮子里</strong></p>
<p>即使前面两条都未满足，那么我们是否要把所有的工作负载部署到一个集群？如果集群控制面出现故障，那么所有的服务都会受到影响。也许大家认为Kubernetes的控制面本身就是高可用的（三个api-server），不会有整个控制层不可用的可能。其实则不然，我们在生产环境中，已经处理很多次类似故障了。如果一个应用（一般指需要调用api-server接口的应用）在大量地调用api-server，会导致api-server接连挂掉，最终不可用。直到找到故障应用，并把故障应用删除。所以在生产环境中，一是需要严格控制访问api-server的权限，二是需要做好测试，三是可以考虑业务应用和基础设施分开部署。其实&quot;选择单集群 or 多集群&quot;和&quot;选择一台超算 or 多台普通机器&quot;类似。后来分布式计算的发展说明大家选择了多个普通机器。</p>
</li>
</ul>
<h2 id="二-现状">二． 现状</h2>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-3454325345345.jpeg" alt="img"></p>
<center>图2.1 企业云服务使用情况</center>
<p>根据最新的调查报告显示（如图2.1），超过 93%的企业正同时使用多个云厂商的服务。云原生技术和云市场不断成熟，多云、多集群部署已经成为常态，未来将是编程式多云管理服务的时代。而业务部署到多云或多集群，它其实是分几个阶段的:</p>
<p><strong>典型阶段 1：多云多地部署，统一管理运维，减少重复劳动（如图2.2）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-1622782645896-20210604142023145-20210604142105429.jpeg" alt="img"></p>
<center>图2.2 阶段一</center>
<p>第一个阶段，我们认为是多地部署统一运维管理，可以理解为是多个互操作的孤岛，互操作意味着在不同的环境，不同的云上，所用软件的技术栈是一套标准化的，在进行公有云、公有云 1、公有云 2 互相切换时，操作命令所输入的命令请求都是一样的，但其之间没有任何业务相关性或业务相关性非常弱，此时去做统一的应用交付，比如部署运维，要么手动执行重复的命令或者脚本化，或者最简单的用一套 CI/CD 的系统堆上去即可。因为在这个阶段大部分的业务相对来说比较固定，部署在哪个公有云、哪个数据中心，哪个机房，不需要太多的动态性和变化性。</p>
<p><strong>典型阶段 2：多云统一资源池，应对业务压力波动（如图2.3）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-21312321312312.jpeg" alt="img"></p>
<center>图2.3 阶段二</center>
<p>第二个阶段为统一资源池，则会对资源池的动态性有一定的诉求。一般来说，在此处我们所认为的应用交付并不是一个简单的 CI/CD，因为我们希望动态性之后，流量也能够随之迁移。在这种情况下，上面的应用交付就需要具备自动调度的能力，流量可以根据实例数的分布情况自己去获取。当然也会有其他情况，比如用一些简单的脚本化来处理你的流量，也可以认为达到了第二个阶段。当然理想的状态下，我们认为这些应该是全自动化的。</p>
<p><strong>典型阶段 3：多云协同，统一应用平台，业务跨云部署（如图2.4）</strong></p>
<p><img src="https://pic4.zhimg.com/v2-97e547e14a377b3b489309ef4881a24d_1440w.jpg" alt="img"></p>
<center>图2.4 阶段三</center>
<p>第三个阶段是我们认为当前可预见到的一个多云和多集群的最终形态，也是我们所认为一个理想中的形态。其实不论用集群、Kubernetes 或以前的虚拟机，从整个云计算的发展历史来看，其实一直在不断的突破边界，或者说重新去定义边界。比如最早的时候装一些新的应用、部署新的服务，需要一台物理服务器，而边界非常不灵活，当后来有了虚机、容器，颗粒度变小了，但在跨机器跨环境的访问形态下，又产生了很多新的挑战，所以 Kubernetes 的出现其实在产生了这么多细腻度的容器之后，重新画一个大的集群作为边界。</p>
<p>而多云其实是在这些不断演进的边界基础上，当在发展到一定的阶段受到数据中心或云的限制，可以用多云的技术来突破云的边界，突破集群的边界，真正的做到业务的应用可以自由的在集群、在云之间灵活的部署和迁移。</p>
<p>但其实在云原生话题下，多云仍然存在非常多的挑战，原因有以下几点：</p>
<ul>
<li>集群繁多：繁琐重复的集群配置、云厂商的集群管理差异、碎片化的 API 访问入口</li>
<li>业务分散：应用在各集群的差异化配置、业务跨云访问、集群间的应用同步</li>
<li>集群的边界限制：资源调度受限于集群、应用可用性受限于集群、弹性伸缩受限于集群</li>
<li>厂商绑定：业务部署的“黏性”、缺少自动的故障迁移、缺少中立的开源多集群编排项目</li>
</ul>
<h2 id="三-技术方案">三． 技术方案</h2>
<h3 id="31整体设计">3.1整体设计</h3>
<h4 id="311什么是karmada">3.1.1什么是karmada</h4>
<p>Karmada（Kubernetes Armada）是一个Kubernetes管理系统如图3.1所示。</p>
<p>它是一个kubernetes多集群管理的插件，运行在kubernetes集群里，可让您跨多个Kubernetes群集和云运行您的云原生应用程序，而无需更改应用程序。通过使用Kubernetes原生API并提供高级调度功能，Karmada可以实现真正的开放式多云Kubernetes。</p>
<p>Karmada旨在为多云和混合云场景中的多集群应用程序管理提供交钥匙自动化，其关键功能包括集中式多云管理，高可用性，故障恢复和流量调度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-20210604133810794.jpeg" alt="img"></p>
<center>图3.1 Karmada的组成</center>
<h4 id="312方案对比">3.1.2方案对比</h4>
<table>
<thead>
<tr>
<th>多集群管理工具</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rancher</td>
<td>组件多而重量，可视化管理，直观，操作繁琐，复杂。</td>
</tr>
<tr>
<td>Karmada</td>
<td>组件少而轻量，命令行工具，配置化管理，操作便携，解耦性强，插件式。</td>
</tr>
</tbody>
</table>
<h4 id="313为什么使用karmada">3.1.3为什么使用karmada</h4>
<ul>
<li><strong>兼容K8s本机API</strong>
<ul>
<li>零变化升级，从单集群到多集群</li>
<li>无缝集成现有K8s工具链</li>
</ul>
</li>
<li><strong>内嵌策略，开箱即用</strong>
<ul>
<li>方案的内置策略集，包括：主动-主动，远程灾难恢复，地理冗余等</li>
<li>跨集群应用程序可在多集群上自动扩展，故障转移和负载均衡</li>
</ul>
</li>
<li><strong>避免供应商锁定</strong>
<ul>
<li>与主流云提供商集成</li>
<li>自动分配，跨集群迁移</li>
<li>不依赖于专有的供应商编排</li>
</ul>
</li>
<li><strong>集中管理</strong>
<ul>
<li>位置不可知集群管理</li>
<li>在本地或边缘的公共云中支持集群</li>
</ul>
</li>
<li><strong>卓有成效的多集群调度策略</strong>
<ul>
<li>群集亲和力，多群集拆分/重新平衡，</li>
<li>多维HA：区域/可用区/群集/提供程序</li>
</ul>
</li>
<li><strong>开放和中立</strong>
<ul>
<li>由互联网，金融，制造业，电信，云提供商等共同发起</li>
<li>CNCF开放治理的目标</li>
</ul>
</li>
</ul>
<p>​        包括主要的模块和流程描述</p>
<h3 id="32关键技术">3.2关键技术</h3>
<h4 id="321karmada组件介绍">3.2.1karmada组件介绍</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-20210604134029874.png" alt="Architecture"></p>
<center>图3.2 Karmada的组成</center>
<p>Karmada Control Plane 由以下组件组成：</p>
<ul>
<li>Karmada API Server</li>
<li>Karmada Controller Manager</li>
<li>Karmada Scheduler</li>
</ul>
<p>ETCD存储karmada API对象，API Server是所有其他组件都可以与之通信的REST端点，而Karmada Controller Manager将根据您通过API服务器创建的API对象执行操作。</p>
<p>Karmada控制器管理器运行各种控制器，这些控制器监视karmada对象，然后与基础集群的API服务器对话以创建常规的Kubernetes资源。</p>
<p>（1）Cluster Controller：将Kubernetes集群附加到Karmada，以通过创建集群对象来管理集群的生命周期。</p>
<p>（2）Policy Controller：控制器监视PropagationPolicy对象。添加PropagationPolicy对象时，它将选择与resourceSelector匹配的一组资源，并为每个资源对象创建ResourceBinding。</p>
<p>（3）Binding Controller：控制器监视ResourceBinding对象，并使用单个资源清单创建与每个集群相对应的Work对象。</p>
<p>（4）Execution Controller：控制器监视工作对象，当创建工作对象时，它将资源分配给成员集群。</p>
<h4 id="322karmada工作流">3.2.2karmada工作流</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-423423423423423.png" alt="karmada-resource-relation.png"></p>
<center>图3.3 资源传播到成员集群时如何使用Karmada资源</center>
<p><strong>Resource template</strong>：Karmada使用Kubernetes自己的API定义的Resource template，以使其易于与Kubernetes上已采用的现有工具集成</p>
<p><strong>Propagation Policy</strong>:：Karmada提供了Propagation(placement) Policy API，以定义多集群调度和传播需求。</p>
<ul>
<li>支持策略1：n映射：工作负载，用户无需在每次创建联合应用程序时都指出调度约束</li>
<li>使用默认策略，用户可以仅与K8s API进行交互</li>
</ul>
<p><strong>Override Policy</strong>：Karmada提供独立的Override Policy API，用于专门化与群集相关的配置自动化。例如：</p>
<ul>
<li>根据成员群集区域覆盖图像前缀</li>
<li>根据云提供商覆盖StorageClass</li>
</ul>
<p>图3.3显示了将资源传播到成员集群时如何使用Karmada资源。</p>
<h2 id="四实验验证">四．实验验证</h2>
<p>Karmada使用Kubernetes自己的API定义的Resource template，使得它与Kubernetes上已采用的现有工具集成。本次实验主要用来验证karamada多集群管理的特性，如利用Propagation Policy策略传播deployment，karamada对多集群kubernetes污点容忍度的配置支持，karmada利用Override Policy对kubernetes群集配置自动化修改pod标签以及karamada对kubernetes的跨集群调度策略。</p>
<h3 id="41安装部署">4.1安装部署</h3>
<ul>
<li>软硬件环境</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>系统</td>
<td>UnionTech OS-20-20210313150438-1_x86_64</td>
</tr>
<tr>
<td>内核</td>
<td>Linux  5.7.7-amd64-desktop</td>
</tr>
<tr>
<td>Docker</td>
<td>19.03.8</td>
</tr>
<tr>
<td>Kubernetes</td>
<td>1.21.1</td>
</tr>
<tr>
<td>Kind</td>
<td>0.11.0</td>
</tr>
<tr>
<td>Karmada</td>
<td>0.6</td>
</tr>
</tbody>
</table>
<pre><code class="language-shell">$ git clone https://github.com/karmada-io/karmada
$ cd karmada
$  hack/local-up-karmada.sh
</code></pre>
<p>该脚本<code>hack/local-up-karmada.sh</code>将为您执行以下任务：</p>
<ul>
<li>启动Kubernetes集群以运行karmada控制平面。的<code>host cluster</code></li>
<li>根据当前代码库构建karmada控制平面组件</li>
<li>在上部署karmada控制平面组件<code>host cluster</code></li>
</ul>
<p>部署踩坑：</p>
<p>①设置goproxy代理</p>
<p>②etcd准备失败，需要拉取国内源的etcd的镜像，修改所有k8s.gcr.io镜像。更改 imagePullPolicy: Always 为 imagePullPolicy: IfNotPresent</p>
<pre><code class="language-shell">#配置环境变量
$ source /etc/profile
export KUBECONFIG=$KUBECONFIG:/root/.kube/karmada.config:$HOME/.kube/karmada-host.config

$ kubectl config get-contexts
CURRENT   NAME                CLUSTER             AUTHINFO            NAMESPACE
          karmada-apiserver   karmada-apiserver   karmada-apiserver
          karmada-host        kind-karmada-host   kind-karmada-host            
#切换到karmada组件所在集群
$ kubectl config use-context  karmada-host

$ kubectl get nodes
NAME                         STATUS   ROLES                  AGE   VERSION
karmada-host-control-plane   Ready    control-plane,master   10m   v1.21.1
$ kubectl get pods  -n kube-system
NAME                                                 READY   STATUS    RESTARTS   AGE
coredns-558bd4d5db-8hmlj                             1/1     Running   0          12m
coredns-558bd4d5db-pt9pd                             1/1     Running   0          12m
etcd-karmada-host-control-plane                      1/1     Running   0          13m
kindnet-qbt6q                                        1/1     Running   0          12m
kube-apiserver-karmada-host-control-plane            1/1     Running   0          13m
kube-controller-manager-karmada-host-control-plane   1/1     Running   0          13m
kube-proxy-gvcp2                                     1/1     Running   0          12m
kube-scheduler-karmada-host-control-plane            1/1     Running   0          13m

#karada各个组件的运行状态
$ kubectl get pods  -n karmada-system
NAME                                               READY   STATUS    RESTARTS   AGE
etcd-0                                             1/1     Running   0          13m
karmada-apiserver-d445d4f75-c492q                  1/1     Running   0          13m
karmada-controller-manager-bf8cc4f75-twplr         1/1     Running   0          12m
karmada-kube-controller-manager-77d8d4d78b-78p6g   1/1     Running   0          12m
karmada-scheduler-779fd9c778-pqtwb                 1/1     Running   0          12m
karmada-webhook-65fc87f89d-qz8ws                   1/1     Running   0          12m

注：  
① 
  ------------------------------------------------------
  |    Context Name   |          Purpose               |
  |----------------------------------------------------|
  | karmada-host      | the cluster karmada install in |
  |----------------------------------------------------|
  | karmada-apiserver | karmada control plane          |
  ------------------------------------------------------
② kindnet：为Kubernetes提供一个简单的CNI插件，该插件具有IPv4和IPv6支持，可提供集群网络。它的诞生，是因为当前的CNI插件缺少IPv6支持，并且没有自动替代方案来创建具有IPv6的多节点kubernetes集群。当所有群集节点都属于同一子网时，该插件仅在“简单”网络环境中工作。作为嵌入式ipmasq代理，它是KIND的默认CNI插件。
</code></pre>
<h3 id="42创建成员集群">4.2创建成员集群</h3>
<p>创建一个名为<code>member1</code>的集群，并希望将<code>KUBECONFIG</code>文件放入<code>$HOME/.kube/karmada.config</code>。运行以下命令：</p>
<pre><code class="language-shell">$ kubectl config use-context  karmada-apiserver
$ hack/create-cluster.sh member1 $HOME/.kube/karmada.config
$ kubectl get nodes
NAME                    STATUS   ROLES                  AGE    VERSION
member1-control-plane   Ready    control-plane,master   3m7s   v1.21.1
$ hack/create-cluster.sh member2  $HOME/.kube/karmada.config
NAME                    STATUS   ROLES                  AGE   VERSION
member2-control-plane   Ready    control-plane,master   87s   v1.21.1
$ kubectl config get-contexts
CURRENT   NAME                CLUSTER             AUTHINFO            NAMESPACE
*         karmada-apiserver   karmada-apiserver   karmada-apiserver
          karmada-host        kind-karmada-host   kind-karmada-host
          member1             kind-member1        kind-member1
          member2             kind-member2        kind-member2
</code></pre>
<p>该脚本<code>hack/create-cluster.sh</code>将按种类创建一个独立的群集。</p>
<h3 id="43将成员集群加入karmada控制平面">4.3将成员集群加入karmada控制平面</h3>
<p>该命令<code>karmadactl</code>将有助于将成员集群加入karmada控制平面，在此之前，我们应切换到karmada apiserver</p>
<pre><code class="language-shell">$ kubectl config use-context karmada-apiserver
</code></pre>
<p>然后，安装<code>karmadactl</code>命令并加入成员集群：</p>
<pre><code class="language-shell">$ go get github.com/karmada-io/karmada/cmd/karmadactl
$ cp  /root/go/bin/karmadactl  /usr/bin/
$ karmadactl join member1 --cluster-kubeconfig=$HOME/.kube/karmada.config
$ karmadactl join member2 --cluster-kubeconfig=$HOME/.kube/karmada.config
$ kubectl get clusters
NAME      VERSION   MODE   READY   AGE
member1   v1.21.1   Push   True    6m30s
member2   v1.21.1   Push   True    83s
</code></pre>
<p>该<code>karmadactl join</code>命令将创建一个<code>Cluster</code>对象以反映成员集群。</p>
<h3 id="44在karmada中创建nginx部署">4.4在karmada中创建nginx部署</h3>
<p>首先，创建一个名为的部署<code>nginx</code>：</p>
<pre><code># kubectl create -f samples/nginx/deployment.yaml
</code></pre>
<h3 id="45创建将nginx传播到成员体现的propagationpolicy">4.5创建将Nginx传播到成员体现的PropagationPolicy</h3>
<p>然后，我们需要创建一个策略以将部署驱动到我们的成员参与。</p>
<pre><code class="language-shell">$  cat samples/nginx/propagationpolicy.yaml
apiVersion: policy.karmada.io/v1alpha1
kind: PropagationPolicy
metadata:
  name: nginx-propagation
spec:
  resourceSelectors:
    - apiVersion: apps/v1
      kind: Deployment
      name: nginx
  placement:
    clusterAffinity:
      clusterNames:
        - member1       
        - member2
$ kubectl create -f samples/nginx/propagationpolicy.yaml
</code></pre>
<p><strong>resourceSelector</strong></p>
<ul>
<li>支持关联多种资源类型</li>
<li>支持使用 name 或 labelSelector 进行对象筛选</li>
</ul>
<p><strong>placement</strong></p>
<p><strong>clusterAffinity:</strong></p>
<ul>
<li>定义倾向调度的目标集群</li>
<li>支持通过 names 或 labelselector 筛选</li>
</ul>
<p><strong>clusterTolerations:</strong></p>
<ul>
<li>类似单集群中 Pod tolerations 和 node taints</li>
</ul>
<p><strong>spreadConstraints:</strong></p>
<ul>
<li>定义应用分发的 HA 策略</li>
<li>支持对集群动态分组：按 Region、AZ、特性 label 分组，实现不同层级的 HA</li>
</ul>
<p><strong>Override Policy</strong>: 跨集群可重用的差异化配置策略</p>
<h3 id="46从karmada检查部署状态">4.6从karmada检查部署状态</h3>
<p>您可以从karmada检查部署状态，无需访问成员集群：</p>
<pre><code class="language-shell">$ kubectl get deploy -o wide
NAME    READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES   SELECTOR
nginx   20/10   20           20          6m43s   nginx        nginx    app=nginx

#验证pod分布
$ kubectl config use-context member1
Switched to context &quot;member1&quot;.
$ kubectl get nodes
NAME                    STATUS   ROLES                  AGE   VERSION
member1-control-plane   Ready    control-plane,master   61m   v1.21.1
$ kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
nginx-6799fc88d8-48tkr   1/1     Running   0          8m17s
nginx-6799fc88d8-hjvw8   1/1     Running   0          8m17s
nginx-6799fc88d8-kfnhl   1/1     Running   0          8m17s
nginx-6799fc88d8-pjn6k   1/1     Running   0          8m17s
nginx-6799fc88d8-psdn5   1/1     Running   0          8m17s
nginx-6799fc88d8-qk5vr   1/1     Running   0          8m17s
nginx-6799fc88d8-r4kzd   1/1     Running   0          8m17s
nginx-6799fc88d8-s5jfh   1/1     Running   0          8m17s
nginx-6799fc88d8-snlsp   1/1     Running   0          8m17s
nginx-6799fc88d8-zcskf   1/1     Running   0          8m17s
$ kubectl config use-context  member2
Switched to context &quot;member2&quot;.
$ kubectl get nodes
NAME                    STATUS   ROLES                  AGE   VERSION
member2-control-plane   Ready    control-plane,master   26m   v1.21.1
$ kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
nginx-6799fc88d8-5227t   1/1     Running   0          11m
nginx-6799fc88d8-bg5ts   1/1     Running   0          11m
nginx-6799fc88d8-h2jxq   1/1     Running   0          11m
nginx-6799fc88d8-j8mpr   1/1     Running   0          11m
nginx-6799fc88d8-nr8fx   1/1     Running   0          11m
nginx-6799fc88d8-rkjz2   1/1     Running   0          11m
nginx-6799fc88d8-rmxx5   1/1     Running   0          11m
nginx-6799fc88d8-rr5qm   1/1     Running   0          11m
nginx-6799fc88d8-t59n4   1/1     Running   0          11m
nginx-6799fc88d8-wldhj   1/1     Running   0          11m
</code></pre>
<h3 id="47基于群集deployment的支持实验">4.7基于群集deployment的支持实验</h3>
<p>剔除<code>member2</code>集群，删除<code> samples/nginx/propagationpolicy.yaml</code>的成员<code>memboer2</code></p>
<pre><code class="language-shell">$ kubectl config use-context karmada-apiserver#剔除`member2`集群,生效$ kubectl apply -f samples/nginx/propagationpolicy.yaml$ kubectl get deployNAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   10/10   10           10          21m$ kubectl config use-context  member1Switched to context &quot;member1&quot;.$ kubectl get podsNAME                     READY   STATUS    RESTARTS   AGEnginx-6799fc88d8-48tkr   1/1     Running   0          21mnginx-6799fc88d8-hjvw8   1/1     Running   0          21mnginx-6799fc88d8-kfnhl   1/1     Running   0          21mnginx-6799fc88d8-pjn6k   1/1     Running   0          21mnginx-6799fc88d8-psdn5   1/1     Running   0          21mnginx-6799fc88d8-qk5vr   1/1     Running   0          21mnginx-6799fc88d8-r4kzd   1/1     Running   0          21mnginx-6799fc88d8-s5jfh   1/1     Running   0          21mnginx-6799fc88d8-snlsp   1/1     Running   0          21mnginx-6799fc88d8-zcskf   1/1     Running   0          21m$  kubectl config use-context  member2Switched to context &quot;member2&quot;.$ kubectl get podsNo resources found in default namespace.
</code></pre>
<h3 id="48基于群集污点容忍度的支持的支持实验">4.8基于群集污点容忍度的支持的支持实验</h3>
<p>污点和容忍度是节点亲和性是 Pod 的一种属性，它使 Pod 被吸引到一类特定的节点。 这可能出于一种偏好，也可能是硬性要求。Taint（污点）则相反，它使节点能够排斥一类特定的 Pod。</p>
<p>容忍度（Tolerations）是应用于 Pod 上的，允许（但并不要求）Pod 调度到带有与之匹配的污点的节点上。</p>
<p>污点和容忍度（Toleration）相互配合，可以用来避免 Pod 被分配到不合适的节点上。 每个节点上都可以应用一个或多个污点，这表示对于那些不能容忍这些污点的 Pod，是不会被该节点接受的。</p>
<p>节点亲和性 是 Pod 的一种属性，它使 Pod 被吸引到一类特定的节点。 这可能出于一种偏好，也可能是硬性要求。 Taint（污点）则相反，它使节点能够排斥一类特定的 Pod。</p>
<p>容忍度（Tolerations）是应用于 Pod 上的，允许（但并不要求）Pod 调度到带有与之匹配的污点的节点上。</p>
<p>污点和容忍度（Toleration）相互配合，可以用来避免 Pod 被分配到不合适的节点上。 每个节点上都可以应用一个或多个污点，这表示对于那些不能容忍这些污点的 Pod，是不会被该节点接受的。</p>
<pre><code class="language-shell">$ kubectl config use-context member2$ kubectl  taint nodes member2-control-plane   cluster-role.kubernetes.io/member2=:NoSchedule$ kubectl config use-context karmada-apiserver
</code></pre>
<p>群集成员2具有“ NoSchedule”效果的污点仅支持NoSchedule污点：</p>
<pre><code class="language-shell">$ kubectl edit   clusters  member2spec:  apiEndpoint: https://172.18.0.5:6443  secretRef:    name: member2    namespace: karmada-cluster  syncMode: Push  taints:  - effect: NoSchedule    key: cluster-role.kubernetes.io/member2
</code></pre>
<p>具有容忍度的传播策略：</p>
<pre><code class="language-shell">$  vim samples/nginx/propagationpolicy.yaml placement:    clusterAffinity:      clusterNames:      - member1      - member2    clusterTolerations:    - effect: NoSchedule      key: cluster-role.kubernetes.io/member2
</code></pre>
<p>生效</p>
<pre><code class="language-shell">$ kubectl  delete -f samples/nginx/deployment.yamldeployment.apps &quot;nginx&quot; deleted$ kubectl  create  -f samples/nginx/deployment.yamldeployment.apps/nginx created$ kubectl get   deployNAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   10/10   20           10          3m51s$ kubectl config use-context  member2$ kubectl get   podsNAME                     READY   STATUS    RESTARTS   AGEnginx-6799fc88d8-2gmhc   0/1     Pending   0          9m39snginx-6799fc88d8-8mjdt   0/1     Pending   0          9m39snginx-6799fc88d8-hpdl5   0/1     Pending   0          9m39snginx-6799fc88d8-l9d8s   0/1     Pending   0          9m39snginx-6799fc88d8-p87zd   0/1     Pending   0          9m39snginx-6799fc88d8-q7gfc   0/1     Pending   0          9m39snginx-6799fc88d8-qtd4f   0/1     Pending   0          9m39snginx-6799fc88d8-sdp7t   0/1     Pending   0          9m39snginx-6799fc88d8-tlq29   0/1     Pending   0          9m39snginx-6799fc88d8-zqn7x   0/1     Pending   0          9m39s
</code></pre>
<h3 id="49基于跨集群可重用的差异化配置策略支持实验">4.9基于跨集群可重用的差异化配置策略支持实验</h3>
<pre><code class="language-shell">$ kubectl config use-context karmada-apiserver$ kubectl  create  -f samples/nginx/deployment.yamldeployment.apps/nginx created$ kubectl get deployNAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   20/10   20           20          52s
</code></pre>
<p>具有可重用的差异化配置策略：</p>
<pre><code class="language-shell">$ kubectl create -f overridepolicy_simple.yamlapiVersion: policy.karmada.io/v1alpha1kind: OverridePolicymetadata:  name: example-override  namespace: defaultspec:  resourceSelectors:    - apiVersion: apps/v1      kind: Deployment      name: nginx      #namespace:  targetCluster:    clusterNames:      - member1#    labelSelector:												#根据label选择节点#      matchLabels:#        failuredomain.kubernetes.io/region: dc1  overriders:    plaintext:#     - path: &quot;/spec/template/spec/containers/0/image&quot;      #       operator: replace#       value: &quot;dc-1.registry.io/nginx:1.17.0-alpine&quot;    #替换镜像      - path: &quot;/metadata/annotations&quot;        operator: add        value:          foo: bar====补充：# 0.6版本中优化了重载镜像（可配置多个镜像）apiVersion: policy.karmada.io/v1alpha1kind: OverridePolicymetadata:  name: example-override  namespace: defaultspec:  resourceSelectors:    - apiVersion: apps/v1      kind: Deployment      name: nginx  targetCluster:    clusterNames:      - member1    labelSelector:      matchLabels:        location: us  overriders:    imageOverrider:      - component: Registry        operator: replace        value: fictional.registry.us        predicate: spec/components/0/image      - component: Registry        operator: replace        value: fictional.registry.us        predicate: spec/components/1/image
</code></pre>
<p>发现member1的nginx配置生效（如图4.9）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hellocloudnative/PicGoimages@main/202106/image-453436436534634346.png" alt="image-20210601174632223"></p>
<center>图4.1member1中的nginx</center>
<h3 id="410基于跨集群自定义副本调度约束">4.10基于跨集群自定义副本调度约束</h3>
<pre><code class="language-shell">apiVersion: policy.karmada.io/v1alpha1kind: ReplicaSchedulingPolicymetadata:  name: foospec:  resourceSelectors:    - apiVersion: apps/v1      kind: Deployment      name: nginx  totalReplicas: 30  preferences:    staticWeightList:      - targetCluster:          clusterNames: [member1]        weight: 1      - targetCluster:          clusterNames: [member2]        weight: 2
</code></pre>
<h2 id="五小结">五．小结</h2>
<p>​	Karmada 是基于 Kubernetes Federation v1 和 v2 开发，它可以跨多个 Kubernetes 集群和云运行云原生应用程序，而无需对应用程序进行更改。通过直接使用 Kubernetes 原生 API 并提供高级调度功能，Karmada 可以实现真正的开放式多云 Kubernetes。</p>
<h2 id="六参考资料">六．参考资料</h2>
<blockquote>
<p>(1)《karmada github》 <a href="https://github.com/karmada-io/karmada">https://github.com/karmada-io/karmada</a></p>
</blockquote>
</article>


      
        <div class="my-4">
    
    <a href="https://hellocloudnative.github.io/tags/karmada/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#karmada</a>
    
</div>
      

      



      
        <div class="py-2">
  
    <div class="my-8 flex flex-col items-center md:flex-row">
      <a href="https://hellocloudnative.github.io/authors/pengxuan-zhang/" class="md:me-4 text-primary-text h-24 w-24">
        
        
          <img
            src="https://hellocloudnative.github.io/images/icon.png"
            class="bg-primary-bg w-full rounded-full"
            alt="Avatar"
          />
        
      </a>
      <div class="mt-4 w-full md:mt-0 md:w-auto">
        <a
          href="https://hellocloudnative.github.io/authors/pengxuan-zhang/"
          class="mb-2 block border-b pb-1 text-lg font-bold"
        >
          <h3>Pengxuan Zhang</h3>
        </a>
        <span class="block pb-2">专注于云原生技术研究</span>
        
          
          
          
          
          <a href="mailto:200922702@qq.com" class="me-2">
            <i class="fas fa-envelope"></i>
          </a>
        
          
          
          
          
          <a href="https://github.com/hellocloudnative" class="me-2">
            <i class="fab fa-github"></i>
          </a>
        
      </div>
    </div>
  
</div>

      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="https://hellocloudnative.github.io/posts/%E8%BF%81%E7%A7%BB%E6%96%B0%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" class="block">迁移新站后的第一篇博客</a>
      
    </div>
  </div>


      



  <script id="utterances" src="https://utteranc.es/client.js"
            issue-term=title
            repo=hellocloudnative/hellocloudnative.github.io
            theme=github-light
        crossorigin="anonymous"
        async>
</script>
<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
    
      <div class="col-span-2">
        
          
<div class="bg-secondary-bg prose max-w-none rounded p-6">
  <h3>系列文章</h3>
  
    
      <a href="https://hellocloudnative.github.io/posts/%E5%9F%BA%E4%BA%8Ekarmada%E5%BC%95%E6%93%8E%E7%9A%84%E5%A4%9A%E4%BA%91%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" class="no-underline">基于karmada引擎的多云容器编排</a>
      <br />
    
  
</div>

        
        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页内容</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#相关术语">相关术语</a></li>
    <li><a href="#一-问题">一． 问题</a></li>
    <li><a href="#二-现状">二． 现状</a></li>
    <li><a href="#三-技术方案">三． 技术方案</a>
      <ul>
        <li><a href="#31整体设计">3.1整体设计</a>
          <ul>
            <li><a href="#311什么是karmada">3.1.1什么是karmada</a></li>
            <li><a href="#312方案对比">3.1.2方案对比</a></li>
            <li><a href="#313为什么使用karmada">3.1.3为什么使用karmada</a></li>
          </ul>
        </li>
        <li><a href="#32关键技术">3.2关键技术</a>
          <ul>
            <li><a href="#321karmada组件介绍">3.2.1karmada组件介绍</a></li>
            <li><a href="#322karmada工作流">3.2.2karmada工作流</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#四实验验证">四．实验验证</a>
      <ul>
        <li><a href="#41安装部署">4.1安装部署</a></li>
        <li><a href="#42创建成员集群">4.2创建成员集群</a></li>
        <li><a href="#43将成员集群加入karmada控制平面">4.3将成员集群加入karmada控制平面</a></li>
        <li><a href="#44在karmada中创建nginx部署">4.4在karmada中创建nginx部署</a></li>
        <li><a href="#45创建将nginx传播到成员体现的propagationpolicy">4.5创建将Nginx传播到成员体现的PropagationPolicy</a></li>
        <li><a href="#46从karmada检查部署状态">4.6从karmada检查部署状态</a></li>
        <li><a href="#47基于群集deployment的支持实验">4.7基于群集deployment的支持实验</a></li>
        <li><a href="#48基于群集污点容忍度的支持的支持实验">4.8基于群集污点容忍度的支持的支持实验</a></li>
        <li><a href="#49基于跨集群可重用的差异化配置策略支持实验">4.9基于跨集群可重用的差异化配置策略支持实验</a></li>
        <li><a href="#410基于跨集群自定义副本调度约束">4.10基于跨集群自定义副本调度约束</a></li>
      </ul>
    </li>
    <li><a href="#五小结">五．小结</a></li>
    <li><a href="#六参考资料">六．参考资料</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"></span> 次 · </span>
<span id="busuanzi_container_site_uv">您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者</span>
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://hellocloudnative.github.io/">Pengxuan Zhang</a> 
  </p>
</div>
</div>
    </footer>
  </body>
</html>
